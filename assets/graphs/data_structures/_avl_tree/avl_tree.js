
/**
* AVL Tree
*
* The AVL tree is a self-balancing binary search tree. In an AVL tree, the heights
* of the two child subtrees of any node differ by at most one.
*
* Lookup, insertion, and deletion all take O(log n) time in both the average and
* worst cases, where n is the number of nodes in the tree prior to the operation.
* Insertions and deletions may require the tree to be rebalanced by one or more
* tree rotations.
*
* AVL trees are often compared with red–black trees. AVL trees are more rigidly
* balanced than red–black trees, leading to faster retrieval but slower insertion
* and deletion.
*
* Therefore, for 'lookup-intensive' applications, AVL trees are better. For 'real-time'
* applications, red-black trees are better.
*
* Both red-black and AVL trees are height balanced and not weight balanced, where
* nodes keep track of how big their sub-trees are.
*
* Key Operations:
*
* get:    O(log n)
* add:    O(log n)
* remove: O(log n)
*/

// class AVL {
//
// }

// export default AVL;
